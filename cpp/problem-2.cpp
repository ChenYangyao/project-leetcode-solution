#include <mystd.h>
#include <my_random.h>
using namespace std;
using namespace MYSTD;


/**
 * It is easy to generate two random integers, r1, r2, each 
 * follows Uniform(0,2), by the STL facilities.
 *
 * The let r = r1 * 3 + r2, which follows Uniform (0,8).
 * We only accept r when r < 5, this gives a Uniform(0,4); 
 * otherwise r is rejected and generated again.
 * 
 * The above algorithm calls rand3() twice, and has 5/9
 * acceptance. On average it calls rand3() 2 * 9/5 = 3.6
 * times for each successful rand5().
 *
 * To a little bit reduce the time complexity, when r >= 5,
 * we generate a r3 ~ Uniform(0,2), and let r' = (r-5)*3 + r3.
 * It is easy to show that r' ~ Uniform(0,11).
 * when r' < 10, we obrain a Uniform(0,4) by r' % 5, otherwise
 * r' is rejected and we goes back to the begining of the 
 * algorithm until success.
 * The time complexity is (9 * 2 + 4) / (5 + 20/6) ~= 2.6 for
 * each rand5().
 *
 * The above consideration is only valid when rand3() takes 
 * most of the computational time. It may break when we use
 * simple (but low-quantity) magic method to generate randomly 
 * number. Thus the true complexity depends on implementation.
 *
 * Author: Yangyao, 2019/0115
 */
class Solution{
public:
	Solution(int seed = 0): rg(0,2,seed){ }
	int rand5(){
		bool failed = true;
		int r1, r2, r3, r;
		do{
			r1 = rg(); r2 = rg();
			r = r1 * 3 + r2;		// r ~ Uniform(0,8)
			if( r < 5 ){
				r %= 5; failed = false;
			}else{
				r3 = rg();
				r = (r-5) * 3 + r3;	// r' ~Uniform(0,11)
				if( r < 10 ){
					r %= 5; failed = false;
				}
			}
		}while( failed );
		return r;
	}
protected:
	MYMATH::RandomsInt<> rg;
};


int main(int argc, char const *argv[]){
	Solution sol;

	// make a simple histogram for the sample generated by rand5()
	const int nbin = 5;
	int bin[ nbin ] = {};
	int nsample = 100000000;
	for (int i = 0; i < nsample; ++i){
		++ bin[ sol.rand5() ];
	}

	// At my computer, this prints
	//		0.199923	0.200056	0.200014	0.199987	0.20002, 
	// indicating the number generated by rand5() is highly randomized.
	for (int i = 0; i < nbin; ++i){
		cout << bin[i] / double( nsample ) << '\t';		
	}
	cout << endl;

	return 0;
}